#include <laser_uav_controllers/nmpc_controller.hpp>
#include <stdio.h>

namespace laser_uav_controllers
{

NmpcController::NmpcController() {
  uav_solver_capsule *acados_ocp_capsule = uav_acados_create_capsule();
  auto                status             = uav_acados_create(acados_ocp_capsule);
  nlp_config                             = uav_acados_get_nlp_config(acados_ocp_capsule);
  nlp_dims                               = uav_acados_get_nlp_dims(acados_ocp_capsule);
  nlp_in                                 = uav_acados_get_nlp_in(acados_ocp_capsule);
  nlp_out                                = uav_acados_get_nlp_out(acados_ocp_capsule);
  nlp_solver                             = uav_acados_get_nlp_solver(acados_ocp_capsule);
  nlp_opts                               = uav_acados_get_nlp_opts(acados_ocp_capsule);

  /* mass_ = mass; */

  // Set Weights for acados
  for (auto i = 0; i < ((NY) * (NY)); i++) {
    acados_in.w[i] = 0.0;
  }
  for (auto i = 0; i < ((NX) * (NX)); i++) {
    acados_in.wn[i] = 0.0;
  }

  /* acados_in.w[0 + 0 * (NU + NX)]   = weights(0); */
  /* acados_in.w[1 + 1 * (NU + NX)]   = weights(1); */
  /* acados_in.w[2 + 2 * (NU + NX)]   = weights(2); */
  /* acados_in.w[3 + 3 * (NU + NX)]   = weights(3); */
  /* acados_in.w[4 + 4 * (NU + NX)]   = weights(4); */
  /* acados_in.w[5 + 5 * (NU + NX)]   = weights(5); */
  /* acados_in.w[6 + 6 * (NU + NX)]   = weights(6); */
  /* acados_in.w[7 + 7 * (NU + NX)]   = weights(7); */
  /* acados_in.w[8 + 8 * (NU + NX)]   = weights(8); */
  /* acados_in.w[9 + 9 * (NU + NX)]   = weights(9); */
  /* acados_in.w[10 + 10 * (NU + NX)] = weights(10); */
  /* acados_in.w[11 + 11 * (NU + NX)] = weights(11); */
  /* acados_in.w[12 + 12 * (NU + NX)] = weights(12); */
  /* acados_in.w[13 + 13 * (NU + NX)] = weights(13); */
  /* acados_in.w[14 + 14 * (NU + NX)] = weights(14); */
  /* acados_in.w[15 + 15 * (NU + NX)] = weights(15); */
  /* acados_in.w[16 + 16 * (NU + NX)] = weights(16); */

  /* acados_in.wn[0 + 0 * NX]   = weights(0) * wn_factor; */
  /* acados_in.wn[1 + 1 * NX]   = weights(1) * wn_factor; */
  /* acados_in.wn[2 + 2 * NX]   = weights(2) * wn_factor; */
  /* acados_in.wn[3 + 3 * NX]   = weights(3) * wn_factor; */
  /* acados_in.wn[4 + 4 * NX]   = weights(4) * wn_factor; */
  /* acados_in.wn[5 + 5 * NX]   = weights(5) * wn_factor; */
  /* acados_in.wn[6 + 6 * NX]   = weights(6) * wn_factor; */
  /* acados_in.wn[7 + 7 * NX]   = weights(7) * wn_factor; */
  /* acados_in.wn[8 + 8 * NX]   = weights(8) * wn_factor; */
  /* acados_in.wn[9 + 9 * NX]   = weights(9) * wn_factor; */
  /* acados_in.wn[10 + 10 * NX] = weights(10) * wn_factor; */
  /* acados_in.wn[11 + 11 * NX] = weights(11) * wn_factor; */
  /* acados_in.wn[12 + 12 * NX] = weights(12) * wn_factor; */
  mass_ = 3.0;
  ct_   = 7.97e-08;
  uss_  = sqrt((mass_ * 9.8) / (4 * ct_));

  acados_in.w[0 + 0 * (NU + NX)]   = 120.0;
  acados_in.w[1 + 1 * (NU + NX)]   = 100.0;
  acados_in.w[2 + 2 * (NU + NX)]   = 100.0;
  acados_in.w[3 + 3 * (NU + NX)]   = 1.0e-3;
  acados_in.w[4 + 4 * (NU + NX)]   = 1.0e-3;
  acados_in.w[5 + 5 * (NU + NX)]   = 1.0e-3;
  acados_in.w[6 + 6 * (NU + NX)]   = 1.0e-3;
  acados_in.w[7 + 7 * (NU + NX)]   = 7e-1;
  acados_in.w[8 + 8 * (NU + NX)]   = 1.0;
  acados_in.w[9 + 9 * (NU + NX)]   = 4.0;
  acados_in.w[10 + 10 * (NU + NX)] = 1.0e-5;
  acados_in.w[11 + 11 * (NU + NX)] = 1.0e-5;
  acados_in.w[12 + 12 * (NU + NX)] = 10.0;
  acados_in.w[13 + 13 * (NU + NX)] = 0.06;
  acados_in.w[14 + 14 * (NU + NX)] = 0.06;
  acados_in.w[15 + 15 * (NU + NX)] = 0.06;
  acados_in.w[16 + 16 * (NU + NX)] = 0.06;

  acados_in.wn[0 + 0 * NX]   = 120.0 * 50;
  acados_in.wn[1 + 1 * NX]   = 100.0 * 50;
  acados_in.wn[2 + 2 * NX]   = 100.0 * 50;
  acados_in.wn[3 + 3 * NX]   = 1.0e-3 * 50;
  acados_in.wn[4 + 4 * NX]   = 1.0e-3 * 50;
  acados_in.wn[5 + 5 * NX]   = 1.0e-3 * 50;
  acados_in.wn[6 + 6 * NX]   = 1.0e-3 * 50;
  acados_in.wn[7 + 7 * NX]   = 7e-1 * 50;
  acados_in.wn[8 + 8 * NX]   = 1.0 * 50;
  acados_in.wn[9 + 9 * NX]   = 4.0 * 50;
  acados_in.wn[10 + 10 * NX] = 1.0e-5 * 50;
  acados_in.wn[11 + 11 * NX] = 1.0e-5 * 50;
  acados_in.wn[12 + 12 * NX] = 10.0 * 50;

  // end of set weights
}

void NmpcController::getCorrection(geometry_msgs::msg::Pose reference, const nav_msgs::msg::Odometry msg) {
  // Update reference
  double yref[(NY * N) + NY];
  for (auto i = 0; i < N + 1; i++) {
    yref[i * NY + 0]  = reference.position.x;  // x
    yref[i * NY + 1]  = reference.position.y;  // y
    yref[i * NY + 2]  = reference.position.z;  // z
    yref[i * NY + 3]  = 1.00;                  // qw
    yref[i * NY + 4]  = 0.00;                  // qx
    yref[i * NY + 5]  = 0.00;                  // qy
    yref[i * NY + 6]  = 0.00;                  // qz
    yref[i * NY + 7]  = 0.00;                  // vbx
    yref[i * NY + 8]  = 0.00;                  // vby
    yref[i * NY + 9]  = 0.00;                  // vbz
    yref[i * NY + 10] = 0.00;                  // wx
    yref[i * NY + 11] = 0.00;                  // wy
    yref[i * NY + 12] = 0.00;                  // wz
    yref[i * NY + 13] = uss_;                  // w1
    yref[i * NY + 14] = uss_;                  // w2
    yref[i * NY + 15] = uss_;                  // w3
    yref[i * NY + 16] = uss_;                  // w4
  }

  // --- Read Estimate
  acados_in.x0[x] = msg.pose.pose.position.x;
  acados_in.x0[y] = msg.pose.pose.position.y;
  acados_in.x0[z] = msg.pose.pose.position.z;

  acados_in.x0[qw] = msg.pose.pose.orientation.w;
  acados_in.x0[qx] = msg.pose.pose.orientation.x;
  acados_in.x0[qy] = msg.pose.pose.orientation.y;
  acados_in.x0[qz] = msg.pose.pose.orientation.z;

  acados_in.x0[vbx] = msg.twist.twist.linear.x;
  acados_in.x0[vby] = msg.twist.twist.linear.y;
  acados_in.x0[vbz] = msg.twist.twist.linear.z;

  acados_in.x0[wx] = msg.twist.twist.angular.x;
  acados_in.x0[wy] = msg.twist.twist.angular.y;
  acados_in.x0[wz] = msg.twist.twist.angular.z;

  ocp_nlp_constraints_model_set(nlp_config, nlp_dims, nlp_in, 0, "lbx", acados_in.x0);
  ocp_nlp_constraints_model_set(nlp_config, nlp_dims, nlp_in, 0, "ubx", acados_in.x0);


  for (auto i = 0; i < N; i++) {
    for (auto j = 0; j < NY; ++j) {
      acados_in.yref[i * NY + j] = yref[i * NY + j];
    }
  }

  for (auto i = 0; i < NYN; i++) {
    acados_in.yref_e[i] = yref[N * NY + i];
  }

  for (auto i = 0; i < N; i++) {
    ocp_nlp_cost_model_set(nlp_config, nlp_dims, nlp_in, i, "yref", acados_in.yref + i * NY);
  }
  ocp_nlp_cost_model_set(nlp_config, nlp_dims, nlp_in, N, "yref", acados_in.yref_e);

  for (auto i = 0; i < N; i++) {
    ocp_nlp_cost_model_set(nlp_config, nlp_dims, nlp_in, i, "W", acados_in.w);
  }
  ocp_nlp_cost_model_set(nlp_config, nlp_dims, nlp_in, N, "W", acados_in.wn);

  // set constraints
  ocp_nlp_constraints_model_set(nlp_config, nlp_dims, nlp_in, 0, "lbu", acados_out.u1);
  ocp_nlp_constraints_model_set(nlp_config, nlp_dims, nlp_in, 0, "ubu", acados_out.u1);

  // initialize solution
  for (int i = 0; i < N; i++) {
    ocp_nlp_out_set(nlp_config, nlp_dims, nlp_out, i, "x", acados_in.x0);
    ocp_nlp_out_set(nlp_config, nlp_dims, nlp_out, i, "u", acados_out.u1);
  }
  ocp_nlp_out_set(nlp_config, nlp_dims, nlp_out, N, "x", acados_in.x0);

  /* printf("mamaco\n\n\n\n\n\n"); */

  // call solver
  printf("acados status solve: %d\n\n\n\n", uav_acados_solve(acados_ocp_capsule));
  /* // assign output signals */
  /* acados_out.status  = acados_status; */
  /* acados_out.KKT_res = (double)nlp_out->inf_norm_res; */
  /* /1* acados_out.cpu_time = (double)nlp_out->total_time; *1/ */

  /* // get solution */
  /* for (auto i = 0; i < N; i++) { */
  /*   ocp_nlp_out_get(nlp_config, nlp_dims, nlp_out, i, "u", (void *)acados_out.u1); */
  /*   ocp_nlp_out_get(nlp_config, nlp_dims, nlp_out, i, "x", (void *)acados_out.x1); */

  /*   printf("Solution N = %d\n", i + 1); */
  /*   printf("States\n"); */
  /*   printf("x = %f\n", acados_out.x1[0]); */
  /*   printf("y = %f\n", acados_out.x1[1]); */
  /*   printf("z = %f\n", acados_out.x1[2]); */
  /*   printf("w = %f\n", acados_out.x1[3]); */
  /*   printf("x = %f\n", acados_out.x1[4]); */
  /*   printf("y = %f\n", acados_out.x1[5]); */
  /*   printf("z = %f\n", acados_out.x1[6]); */
  /*   printf("vbx = %f\n", acados_out.x1[7]); */
  /*   printf("vby = %f\n", acados_out.x1[8]); */
  /*   printf("vbz = %f\n", acados_out.x1[9]); */
  /*   printf("wx = %f\n", acados_out.x1[10]); */
  /*   printf("wy = %f\n", acados_out.x1[11]); */
  /*   printf("wz = %f\n", acados_out.x1[12]); */
  /*   printf("U\n"); */
  /*   printf("u1 = %f\n", acados_out.u1[0]); */
  /*   printf("u2 = %f\n", acados_out.u1[1]); */
  /*   printf("u3 = %f\n", acados_out.u1[2]); */
  /*   printf("u4 = %f\n", acados_out.u1[3]); */
  /* } */
}
}  // namespace laser_uav_controllers
